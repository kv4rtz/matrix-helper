```python
def gauss_method(a, b):
    n = len(b)  # Определяем размер системы (количество уравнений)

    # Прямой ход (приведение матрицы к треугольному виду)
    for k in range(n):
        # Проверяем, что элемент на диагонали не равен нулю (чтобы избежать деления на ноль)
        if a[k][k] == 0:
            raise ValueError("Нулевой элемент на диагонали. Решение невозможно.")

        # Обнуляем элементы ниже главного элемента в столбце k
        for i in range(k + 1, n):
            factor = a[i][k] / a[k][k]  # Вычисляем множитель для обнуления строки i
            for j in range(k, n):
                a[i][j] -= factor * a[k][j]  # Отнимаем от строки i строку k, умноженную на множитель
            b[i] -= factor * b[k]  # Аналогично корректируем вектор свободных членов

    # Обратный ход (нахождение решений)
    x = [0 for _ in range(n)]  # Инициализируем вектор решений нулями
    for i in range(n - 1, -1, -1):  # Проходим по строкам снизу вверх
        sum_ax = sum(a[i][j] * x[j] for j in range(i + 1, n))  # Вычисляем сумму известных решений (после текущего элемента)
        x[i] = (b[i] - sum_ax) / a[i][i]  # Находим текущее решение x[i]

    return x  # Возвращаем вектор решений
```

### Разбор каждой строки:

1. `n = len(b)`:

   - Мы определяем количество уравнений, исходя из длины вектора свободных членов \( b \). Это же количество уравнений соответствует размеру матрицы коэффициентов \( A \), потому что матрица \( A \) квадратная.

2. `for k in range(n):`

   - Внешний цикл проходит по каждому уравнению и по каждому элементу на диагонали матрицы \( A \), начиная с первого. Этот элемент используется для обнуления коэффициентов ниже него.

3. `if a[k][k] == 0: raise ValueError("Нулевой элемент на диагонали. Решение невозможно.")`

   - Если на диагонали находится нулевой элемент, это приведёт к ошибке деления на ноль. Такая ситуация требует перестановки строк или другой обработки (в данном случае выбрасывается исключение).

4. `for i in range(k + 1, n):`

   - Этот цикл проходит по строкам, которые находятся ниже текущей строки (строки \( k \)) и занимается обнулением элементов в соответствующих столбцах (чтобы привести систему к треугольному виду).

5. `factor = a[i][k] / a[k][k]`

   - Вычисляем коэффициент, который показывает, во сколько раз нужно умножить текущую строку \( k \), чтобы обнулить элемент в строке \( i \) (ниже текущего элемента \( a[k][k] \)).

6. `for j in range(k, n):`

   - Внутренний цикл проходит по всем элементам строки \( i \), начиная с элемента \( a[i][k] \) (который мы обнуляем), и корректирует их, отнимая элементы строки \( k \), умноженные на множитель \( factor \).

7. `a[i][j] -= factor * a[k][j]`

   - Это основное действие в алгоритме: вычитание строки \( k \), умноженной на коэффициент \( factor \), из строки \( i \). Это делается для обнуления элементов ниже главного элемента в столбце \( k \).

8. `b[i] -= factor * b[k]`

   - Также корректируется вектор свободных членов \( b \), чтобы изменения в строках матрицы \( A \) соответствовали правой части уравнений.

9. `x = [0 for _ in range(n)]`

   - Инициализируем вектор решений \( x \) нулями. Позже мы будем заполнять его рассчитанными значениями переменных.

10. `for i in range(n - 1, -1, -1):`

    - Этот цикл выполняет **обратный ход**, начиная с последнего уравнения. Мы идём по строкам системы в обратном порядке, начиная с самого нижнего уравнения.

11. `sum_ax = sum(a[i][j] * x[j] for j in range(i + 1, n))`

    - Вычисляем сумму произведений известных решений на коэффициенты \( a[i][j] \) (для тех переменных, которые были уже найдены в предыдущих шагах цикла). Это нужно для того, чтобы выразить текущее неизвестное \( x[i] \).

12. `x[i] = (b[i] - sum_ax) / a[i][i]`

    - Теперь можем найти текущее неизвестное \( x[i] \), вычитая из свободного члена \( b[i] \) сумму произведений уже известных решений и деля результат на коэффициент \( a[i][i] \) (коэффициент перед \( x[i] \)).

13. `return x`
    - Возвращаем вектор решений \( x \), который содержит найденные значения переменных \( x_1, x_2, x_3 \).

### Итог:

Метод Гаусса последовательно преобразует систему уравнений, сводя её к треугольному виду, и затем находит решения методом обратной подстановки.
